// Code generated by counterfeiter. DO NOT EDIT.
package terraformfakes

import (
	"sync"
	"terraform-resource/terraform"
)

type FakeClient struct {
	InitWithBackendStub        func() error
	initWithBackendMutex       sync.RWMutex
	initWithBackendArgsForCall []struct{}
	initWithBackendReturns     struct {
		result1 error
	}
	initWithBackendReturnsOnCall map[int]struct {
		result1 error
	}
	InitWithoutBackendStub        func() error
	initWithoutBackendMutex       sync.RWMutex
	initWithoutBackendArgsForCall []struct{}
	initWithoutBackendReturns     struct {
		result1 error
	}
	initWithoutBackendReturnsOnCall map[int]struct {
		result1 error
	}
	ApplyStub        func() error
	applyMutex       sync.RWMutex
	applyArgsForCall []struct{}
	applyReturns     struct {
		result1 error
	}
	applyReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	PlanStub        func() error
	planMutex       sync.RWMutex
	planArgsForCall []struct{}
	planReturns     struct {
		result1 error
	}
	planReturnsOnCall map[int]struct {
		result1 error
	}
	OutputStub        func(string) (map[string]map[string]interface{}, error)
	outputMutex       sync.RWMutex
	outputArgsForCall []struct {
		arg1 string
	}
	outputReturns struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	outputReturnsOnCall map[int]struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	OutputWithLegacyStorageStub        func() (map[string]map[string]interface{}, error)
	outputWithLegacyStorageMutex       sync.RWMutex
	outputWithLegacyStorageArgsForCall []struct{}
	outputWithLegacyStorageReturns     struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	outputWithLegacyStorageReturnsOnCall map[int]struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	VersionStub        func() (string, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct{}
	versionReturns     struct {
		result1 string
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ImportStub        func(string) error
	importMutex       sync.RWMutex
	importArgsForCall []struct {
		arg1 string
	}
	importReturns struct {
		result1 error
	}
	importReturnsOnCall map[int]struct {
		result1 error
	}
	ImportWithLegacyStorageStub        func() error
	importWithLegacyStorageMutex       sync.RWMutex
	importWithLegacyStorageArgsForCall []struct{}
	importWithLegacyStorageReturns     struct {
		result1 error
	}
	importWithLegacyStorageReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceListStub        func() ([]string, error)
	workspaceListMutex       sync.RWMutex
	workspaceListArgsForCall []struct{}
	workspaceListReturns     struct {
		result1 []string
		result2 error
	}
	workspaceListReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	WorkspaceNewStub        func(string) error
	workspaceNewMutex       sync.RWMutex
	workspaceNewArgsForCall []struct {
		arg1 string
	}
	workspaceNewReturns struct {
		result1 error
	}
	workspaceNewReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceNewFromExistingStateFileStub        func(string, string) error
	workspaceNewFromExistingStateFileMutex       sync.RWMutex
	workspaceNewFromExistingStateFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	workspaceNewFromExistingStateFileReturns struct {
		result1 error
	}
	workspaceNewFromExistingStateFileReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceSelectStub        func(string) error
	workspaceSelectMutex       sync.RWMutex
	workspaceSelectArgsForCall []struct {
		arg1 string
	}
	workspaceSelectReturns struct {
		result1 error
	}
	workspaceSelectReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceDeleteStub        func(string) error
	workspaceDeleteMutex       sync.RWMutex
	workspaceDeleteArgsForCall []struct {
		arg1 string
	}
	workspaceDeleteReturns struct {
		result1 error
	}
	workspaceDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	StatePullStub        func(string) ([]byte, error)
	statePullMutex       sync.RWMutex
	statePullArgsForCall []struct {
		arg1 string
	}
	statePullReturns struct {
		result1 []byte
		result2 error
	}
	statePullReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	CurrentStateVersionStub        func(string) (terraform.StateVersion, error)
	currentStateVersionMutex       sync.RWMutex
	currentStateVersionArgsForCall []struct {
		arg1 string
	}
	currentStateVersionReturns struct {
		result1 terraform.StateVersion
		result2 error
	}
	currentStateVersionReturnsOnCall map[int]struct {
		result1 terraform.StateVersion
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) InitWithBackend() error {
	fake.initWithBackendMutex.Lock()
	ret, specificReturn := fake.initWithBackendReturnsOnCall[len(fake.initWithBackendArgsForCall)]
	fake.initWithBackendArgsForCall = append(fake.initWithBackendArgsForCall, struct{}{})
	fake.recordInvocation("InitWithBackend", []interface{}{})
	fake.initWithBackendMutex.Unlock()
	if fake.InitWithBackendStub != nil {
		return fake.InitWithBackendStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initWithBackendReturns.result1
}

func (fake *FakeClient) InitWithBackendCallCount() int {
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	return len(fake.initWithBackendArgsForCall)
}

func (fake *FakeClient) InitWithBackendReturns(result1 error) {
	fake.InitWithBackendStub = nil
	fake.initWithBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithBackendReturnsOnCall(i int, result1 error) {
	fake.InitWithBackendStub = nil
	if fake.initWithBackendReturnsOnCall == nil {
		fake.initWithBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackend() error {
	fake.initWithoutBackendMutex.Lock()
	ret, specificReturn := fake.initWithoutBackendReturnsOnCall[len(fake.initWithoutBackendArgsForCall)]
	fake.initWithoutBackendArgsForCall = append(fake.initWithoutBackendArgsForCall, struct{}{})
	fake.recordInvocation("InitWithoutBackend", []interface{}{})
	fake.initWithoutBackendMutex.Unlock()
	if fake.InitWithoutBackendStub != nil {
		return fake.InitWithoutBackendStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initWithoutBackendReturns.result1
}

func (fake *FakeClient) InitWithoutBackendCallCount() int {
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	return len(fake.initWithoutBackendArgsForCall)
}

func (fake *FakeClient) InitWithoutBackendReturns(result1 error) {
	fake.InitWithoutBackendStub = nil
	fake.initWithoutBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackendReturnsOnCall(i int, result1 error) {
	fake.InitWithoutBackendStub = nil
	if fake.initWithoutBackendReturnsOnCall == nil {
		fake.initWithoutBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithoutBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Apply() error {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct{}{})
	fake.recordInvocation("Apply", []interface{}{})
	fake.applyMutex.Unlock()
	if fake.ApplyStub != nil {
		return fake.ApplyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.applyReturns.result1
}

func (fake *FakeClient) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *FakeClient) ApplyReturns(result1 error) {
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ApplyReturnsOnCall(i int, result1 error) {
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyReturns.result1
}

func (fake *FakeClient) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeClient) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DestroyReturnsOnCall(i int, result1 error) {
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Plan() error {
	fake.planMutex.Lock()
	ret, specificReturn := fake.planReturnsOnCall[len(fake.planArgsForCall)]
	fake.planArgsForCall = append(fake.planArgsForCall, struct{}{})
	fake.recordInvocation("Plan", []interface{}{})
	fake.planMutex.Unlock()
	if fake.PlanStub != nil {
		return fake.PlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.planReturns.result1
}

func (fake *FakeClient) PlanCallCount() int {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	return len(fake.planArgsForCall)
}

func (fake *FakeClient) PlanReturns(result1 error) {
	fake.PlanStub = nil
	fake.planReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PlanReturnsOnCall(i int, result1 error) {
	fake.PlanStub = nil
	if fake.planReturnsOnCall == nil {
		fake.planReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.planReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Output(arg1 string) (map[string]map[string]interface{}, error) {
	fake.outputMutex.Lock()
	ret, specificReturn := fake.outputReturnsOnCall[len(fake.outputArgsForCall)]
	fake.outputArgsForCall = append(fake.outputArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Output", []interface{}{arg1})
	fake.outputMutex.Unlock()
	if fake.OutputStub != nil {
		return fake.OutputStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.outputReturns.result1, fake.outputReturns.result2
}

func (fake *FakeClient) OutputCallCount() int {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return len(fake.outputArgsForCall)
}

func (fake *FakeClient) OutputArgsForCall(i int) string {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return fake.outputArgsForCall[i].arg1
}

func (fake *FakeClient) OutputReturns(result1 map[string]map[string]interface{}, result2 error) {
	fake.OutputStub = nil
	fake.outputReturns = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputReturnsOnCall(i int, result1 map[string]map[string]interface{}, result2 error) {
	fake.OutputStub = nil
	if fake.outputReturnsOnCall == nil {
		fake.outputReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]interface{}
			result2 error
		})
	}
	fake.outputReturnsOnCall[i] = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputWithLegacyStorage() (map[string]map[string]interface{}, error) {
	fake.outputWithLegacyStorageMutex.Lock()
	ret, specificReturn := fake.outputWithLegacyStorageReturnsOnCall[len(fake.outputWithLegacyStorageArgsForCall)]
	fake.outputWithLegacyStorageArgsForCall = append(fake.outputWithLegacyStorageArgsForCall, struct{}{})
	fake.recordInvocation("OutputWithLegacyStorage", []interface{}{})
	fake.outputWithLegacyStorageMutex.Unlock()
	if fake.OutputWithLegacyStorageStub != nil {
		return fake.OutputWithLegacyStorageStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.outputWithLegacyStorageReturns.result1, fake.outputWithLegacyStorageReturns.result2
}

func (fake *FakeClient) OutputWithLegacyStorageCallCount() int {
	fake.outputWithLegacyStorageMutex.RLock()
	defer fake.outputWithLegacyStorageMutex.RUnlock()
	return len(fake.outputWithLegacyStorageArgsForCall)
}

func (fake *FakeClient) OutputWithLegacyStorageReturns(result1 map[string]map[string]interface{}, result2 error) {
	fake.OutputWithLegacyStorageStub = nil
	fake.outputWithLegacyStorageReturns = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputWithLegacyStorageReturnsOnCall(i int, result1 map[string]map[string]interface{}, result2 error) {
	fake.OutputWithLegacyStorageStub = nil
	if fake.outputWithLegacyStorageReturnsOnCall == nil {
		fake.outputWithLegacyStorageReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]interface{}
			result2 error
		})
	}
	fake.outputWithLegacyStorageReturnsOnCall[i] = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Version() (string, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct{}{})
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.versionReturns.result1, fake.versionReturns.result2
}

func (fake *FakeClient) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeClient) VersionReturns(result1 string, result2 error) {
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) VersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Import(arg1 string) error {
	fake.importMutex.Lock()
	ret, specificReturn := fake.importReturnsOnCall[len(fake.importArgsForCall)]
	fake.importArgsForCall = append(fake.importArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Import", []interface{}{arg1})
	fake.importMutex.Unlock()
	if fake.ImportStub != nil {
		return fake.ImportStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.importReturns.result1
}

func (fake *FakeClient) ImportCallCount() int {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	return len(fake.importArgsForCall)
}

func (fake *FakeClient) ImportArgsForCall(i int) string {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	return fake.importArgsForCall[i].arg1
}

func (fake *FakeClient) ImportReturns(result1 error) {
	fake.ImportStub = nil
	fake.importReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportReturnsOnCall(i int, result1 error) {
	fake.ImportStub = nil
	if fake.importReturnsOnCall == nil {
		fake.importReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportWithLegacyStorage() error {
	fake.importWithLegacyStorageMutex.Lock()
	ret, specificReturn := fake.importWithLegacyStorageReturnsOnCall[len(fake.importWithLegacyStorageArgsForCall)]
	fake.importWithLegacyStorageArgsForCall = append(fake.importWithLegacyStorageArgsForCall, struct{}{})
	fake.recordInvocation("ImportWithLegacyStorage", []interface{}{})
	fake.importWithLegacyStorageMutex.Unlock()
	if fake.ImportWithLegacyStorageStub != nil {
		return fake.ImportWithLegacyStorageStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.importWithLegacyStorageReturns.result1
}

func (fake *FakeClient) ImportWithLegacyStorageCallCount() int {
	fake.importWithLegacyStorageMutex.RLock()
	defer fake.importWithLegacyStorageMutex.RUnlock()
	return len(fake.importWithLegacyStorageArgsForCall)
}

func (fake *FakeClient) ImportWithLegacyStorageReturns(result1 error) {
	fake.ImportWithLegacyStorageStub = nil
	fake.importWithLegacyStorageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportWithLegacyStorageReturnsOnCall(i int, result1 error) {
	fake.ImportWithLegacyStorageStub = nil
	if fake.importWithLegacyStorageReturnsOnCall == nil {
		fake.importWithLegacyStorageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importWithLegacyStorageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceList() ([]string, error) {
	fake.workspaceListMutex.Lock()
	ret, specificReturn := fake.workspaceListReturnsOnCall[len(fake.workspaceListArgsForCall)]
	fake.workspaceListArgsForCall = append(fake.workspaceListArgsForCall, struct{}{})
	fake.recordInvocation("WorkspaceList", []interface{}{})
	fake.workspaceListMutex.Unlock()
	if fake.WorkspaceListStub != nil {
		return fake.WorkspaceListStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.workspaceListReturns.result1, fake.workspaceListReturns.result2
}

func (fake *FakeClient) WorkspaceListCallCount() int {
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	return len(fake.workspaceListArgsForCall)
}

func (fake *FakeClient) WorkspaceListReturns(result1 []string, result2 error) {
	fake.WorkspaceListStub = nil
	fake.workspaceListReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.WorkspaceListStub = nil
	if fake.workspaceListReturnsOnCall == nil {
		fake.workspaceListReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.workspaceListReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceNew(arg1 string) error {
	fake.workspaceNewMutex.Lock()
	ret, specificReturn := fake.workspaceNewReturnsOnCall[len(fake.workspaceNewArgsForCall)]
	fake.workspaceNewArgsForCall = append(fake.workspaceNewArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkspaceNew", []interface{}{arg1})
	fake.workspaceNewMutex.Unlock()
	if fake.WorkspaceNewStub != nil {
		return fake.WorkspaceNewStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.workspaceNewReturns.result1
}

func (fake *FakeClient) WorkspaceNewCallCount() int {
	fake.workspaceNewMutex.RLock()
	defer fake.workspaceNewMutex.RUnlock()
	return len(fake.workspaceNewArgsForCall)
}

func (fake *FakeClient) WorkspaceNewArgsForCall(i int) string {
	fake.workspaceNewMutex.RLock()
	defer fake.workspaceNewMutex.RUnlock()
	return fake.workspaceNewArgsForCall[i].arg1
}

func (fake *FakeClient) WorkspaceNewReturns(result1 error) {
	fake.WorkspaceNewStub = nil
	fake.workspaceNewReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewReturnsOnCall(i int, result1 error) {
	fake.WorkspaceNewStub = nil
	if fake.workspaceNewReturnsOnCall == nil {
		fake.workspaceNewReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceNewReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFile(arg1 string, arg2 string) error {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	ret, specificReturn := fake.workspaceNewFromExistingStateFileReturnsOnCall[len(fake.workspaceNewFromExistingStateFileArgsForCall)]
	fake.workspaceNewFromExistingStateFileArgsForCall = append(fake.workspaceNewFromExistingStateFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("WorkspaceNewFromExistingStateFile", []interface{}{arg1, arg2})
	fake.workspaceNewFromExistingStateFileMutex.Unlock()
	if fake.WorkspaceNewFromExistingStateFileStub != nil {
		return fake.WorkspaceNewFromExistingStateFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.workspaceNewFromExistingStateFileReturns.result1
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileCallCount() int {
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	return len(fake.workspaceNewFromExistingStateFileArgsForCall)
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileArgsForCall(i int) (string, string) {
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	return fake.workspaceNewFromExistingStateFileArgsForCall[i].arg1, fake.workspaceNewFromExistingStateFileArgsForCall[i].arg2
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileReturns(result1 error) {
	fake.WorkspaceNewFromExistingStateFileStub = nil
	fake.workspaceNewFromExistingStateFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileReturnsOnCall(i int, result1 error) {
	fake.WorkspaceNewFromExistingStateFileStub = nil
	if fake.workspaceNewFromExistingStateFileReturnsOnCall == nil {
		fake.workspaceNewFromExistingStateFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceNewFromExistingStateFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceSelect(arg1 string) error {
	fake.workspaceSelectMutex.Lock()
	ret, specificReturn := fake.workspaceSelectReturnsOnCall[len(fake.workspaceSelectArgsForCall)]
	fake.workspaceSelectArgsForCall = append(fake.workspaceSelectArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkspaceSelect", []interface{}{arg1})
	fake.workspaceSelectMutex.Unlock()
	if fake.WorkspaceSelectStub != nil {
		return fake.WorkspaceSelectStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.workspaceSelectReturns.result1
}

func (fake *FakeClient) WorkspaceSelectCallCount() int {
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	return len(fake.workspaceSelectArgsForCall)
}

func (fake *FakeClient) WorkspaceSelectArgsForCall(i int) string {
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	return fake.workspaceSelectArgsForCall[i].arg1
}

func (fake *FakeClient) WorkspaceSelectReturns(result1 error) {
	fake.WorkspaceSelectStub = nil
	fake.workspaceSelectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceSelectReturnsOnCall(i int, result1 error) {
	fake.WorkspaceSelectStub = nil
	if fake.workspaceSelectReturnsOnCall == nil {
		fake.workspaceSelectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceSelectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDelete(arg1 string) error {
	fake.workspaceDeleteMutex.Lock()
	ret, specificReturn := fake.workspaceDeleteReturnsOnCall[len(fake.workspaceDeleteArgsForCall)]
	fake.workspaceDeleteArgsForCall = append(fake.workspaceDeleteArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkspaceDelete", []interface{}{arg1})
	fake.workspaceDeleteMutex.Unlock()
	if fake.WorkspaceDeleteStub != nil {
		return fake.WorkspaceDeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.workspaceDeleteReturns.result1
}

func (fake *FakeClient) WorkspaceDeleteCallCount() int {
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	return len(fake.workspaceDeleteArgsForCall)
}

func (fake *FakeClient) WorkspaceDeleteArgsForCall(i int) string {
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	return fake.workspaceDeleteArgsForCall[i].arg1
}

func (fake *FakeClient) WorkspaceDeleteReturns(result1 error) {
	fake.WorkspaceDeleteStub = nil
	fake.workspaceDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDeleteReturnsOnCall(i int, result1 error) {
	fake.WorkspaceDeleteStub = nil
	if fake.workspaceDeleteReturnsOnCall == nil {
		fake.workspaceDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StatePull(arg1 string) ([]byte, error) {
	fake.statePullMutex.Lock()
	ret, specificReturn := fake.statePullReturnsOnCall[len(fake.statePullArgsForCall)]
	fake.statePullArgsForCall = append(fake.statePullArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("StatePull", []interface{}{arg1})
	fake.statePullMutex.Unlock()
	if fake.StatePullStub != nil {
		return fake.StatePullStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.statePullReturns.result1, fake.statePullReturns.result2
}

func (fake *FakeClient) StatePullCallCount() int {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	return len(fake.statePullArgsForCall)
}

func (fake *FakeClient) StatePullArgsForCall(i int) string {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	return fake.statePullArgsForCall[i].arg1
}

func (fake *FakeClient) StatePullReturns(result1 []byte, result2 error) {
	fake.StatePullStub = nil
	fake.statePullReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StatePullReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.StatePullStub = nil
	if fake.statePullReturnsOnCall == nil {
		fake.statePullReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.statePullReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CurrentStateVersion(arg1 string) (terraform.StateVersion, error) {
	fake.currentStateVersionMutex.Lock()
	ret, specificReturn := fake.currentStateVersionReturnsOnCall[len(fake.currentStateVersionArgsForCall)]
	fake.currentStateVersionArgsForCall = append(fake.currentStateVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CurrentStateVersion", []interface{}{arg1})
	fake.currentStateVersionMutex.Unlock()
	if fake.CurrentStateVersionStub != nil {
		return fake.CurrentStateVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.currentStateVersionReturns.result1, fake.currentStateVersionReturns.result2
}

func (fake *FakeClient) CurrentStateVersionCallCount() int {
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	return len(fake.currentStateVersionArgsForCall)
}

func (fake *FakeClient) CurrentStateVersionArgsForCall(i int) string {
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	return fake.currentStateVersionArgsForCall[i].arg1
}

func (fake *FakeClient) CurrentStateVersionReturns(result1 terraform.StateVersion, result2 error) {
	fake.CurrentStateVersionStub = nil
	fake.currentStateVersionReturns = struct {
		result1 terraform.StateVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CurrentStateVersionReturnsOnCall(i int, result1 terraform.StateVersion, result2 error) {
	fake.CurrentStateVersionStub = nil
	if fake.currentStateVersionReturnsOnCall == nil {
		fake.currentStateVersionReturnsOnCall = make(map[int]struct {
			result1 terraform.StateVersion
			result2 error
		})
	}
	fake.currentStateVersionReturnsOnCall[i] = struct {
		result1 terraform.StateVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	fake.outputWithLegacyStorageMutex.RLock()
	defer fake.outputWithLegacyStorageMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	fake.importWithLegacyStorageMutex.RLock()
	defer fake.importWithLegacyStorageMutex.RUnlock()
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	fake.workspaceNewMutex.RLock()
	defer fake.workspaceNewMutex.RUnlock()
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ terraform.Client = new(FakeClient)
